import pygame
import random
import math

# Initialize Pygame
pygame.init()

# Constants
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
LIGHT_GREY = (100, 100, 100)
GREY = (128, 128, 128)
LIGHTER_GREY = (180, 180, 180)  # For starting platform
RED = (255, 0, 0)
ORANGE = (255, 165, 0)
BLUE = (0, 100, 255)

# Player constants
PLAYER_SIZE = 20
PLAYER_SPEED = 5
JUMP_STRENGTH = 12
GRAVITY = 0.5
MAX_FALL_SPEED = 15

class Star:
    def __init__(self):
        self.x = random.randint(0, SCREEN_WIDTH)
        self.y = random.randint(0, SCREEN_HEIGHT)
        self.speed = random.uniform(0.5, 2)
        self.size = random.randint(1, 3)
    
    def update(self):
        self.y += self.speed
        if self.y > SCREEN_HEIGHT:
            self.y = -10
            self.x = random.randint(0, SCREEN_WIDTH)
    
    def draw(self, screen):
        pygame.draw.circle(screen, LIGHT_GREY, (int(self.x), int(self.y)), self.size)

class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.vel_x = 0
        self.vel_y = 0
        self.on_ground = False
        self.can_wall_jump = True
        self.can_double_jump = True
        self.wall_jump_timer = 0
        
    def update(self, platforms):
        # Handle input
        keys = pygame.key.get_pressed()
        
        # Initialize jump_pressed if it doesn't exist
        if not hasattr(self, 'jump_pressed'):
            self.jump_pressed = False
        
        # Horizontal movement
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.vel_x = -PLAYER_SPEED
        elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.vel_x = PLAYER_SPEED
        else:
            self.vel_x *= 0.8  # Friction
        
        # Jumping - only trigger on key press, not key hold
        jump_key_pressed = keys[pygame.K_SPACE] or keys[pygame.K_UP] or keys[pygame.K_w]
        
        if jump_key_pressed and not self.jump_pressed:
            self.jump_pressed = True
            if self.on_ground:
                # Ground jump
                self.vel_y = -JUMP_STRENGTH
                self.can_double_jump = True
                self.on_ground = False
            elif self.can_double_jump:
                # Double jump
                self.vel_y = -JUMP_STRENGTH
                self.can_double_jump = False
            elif self.can_wall_jump and self.wall_jump_timer <= 0:
                # Check for wall jump
                wall_left = self.check_wall_collision(platforms, -5, 0)
                wall_right = self.check_wall_collision(platforms, 5, 0)
                if wall_left or wall_right:
                    self.vel_y = -JUMP_STRENGTH
                    self.vel_x = PLAYER_SPEED * 2 if wall_left else -PLAYER_SPEED * 2
                    self.can_wall_jump = False
                    self.wall_jump_timer = 10
        elif not jump_key_pressed:
            self.jump_pressed = False
        
        # Wall jump timer
        if self.wall_jump_timer > 0:
            self.wall_jump_timer -= 1
        
        # Apply gravity
        self.vel_y += GRAVITY
        if self.vel_y > MAX_FALL_SPEED:
            self.vel_y = MAX_FALL_SPEED
        
        # Move horizontally
        self.x += self.vel_x
        if self.x < 0:
            self.x = 0
        elif self.x > SCREEN_WIDTH - PLAYER_SIZE:
            self.x = SCREEN_WIDTH - PLAYER_SIZE
        
        # Check horizontal collisions
        if self.check_collision(platforms):
            self.x -= self.vel_x
            self.vel_x = 0
        
        # Move vertically
        self.y += self.vel_y
        
        # Check vertical collisions
        old_on_ground = self.on_ground
        self.on_ground = False
        
        if self.check_collision(platforms):
            if self.vel_y > 0:  # Falling
                # Land on platform
                self.y -= self.vel_y
                while self.check_collision(platforms):
                    self.y -= 1
                self.vel_y = 0
                self.on_ground = True
                # Reset abilities when landing
                if not old_on_ground:
                    self.can_wall_jump = True
                    self.can_double_jump = True
            else:  # Moving up (hit ceiling)
                self.y -= self.vel_y
                while self.check_collision(platforms):
                    self.y += 1
                self.vel_y = 0
    
    def check_collision(self, platforms):
        player_rect = pygame.Rect(self.x, self.y, PLAYER_SIZE, PLAYER_SIZE)
        for platform in platforms:
            if player_rect.colliderect(platform):
                return True
        return False
    
    def check_wall_collision(self, platforms, offset_x, offset_y):
        player_rect = pygame.Rect(self.x + offset_x, self.y + offset_y, PLAYER_SIZE, PLAYER_SIZE)
        for platform in platforms:
            if player_rect.colliderect(platform):
                return True
        return False
    
    def draw(self, screen):
        pygame.draw.rect(screen, WHITE, (self.x, self.y, PLAYER_SIZE, PLAYER_SIZE))

class Projectile:
    def __init__(self, x, y, vel_x, vel_y, color):
        self.x = x
        self.y = y
        self.vel_x = vel_x
        self.vel_y = vel_y
        self.color = color
        self.size = 6
    
    def update(self):
        self.x += self.vel_x
        self.y += self.vel_y
    
    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.size)
    
    def is_off_screen(self):
        return (self.x < -20 or self.x > SCREEN_WIDTH + 20 or 
                self.y < -20 or self.y > SCREEN_HEIGHT + 20)

class Cannon:
    def __init__(self, x, y, cannon_type="normal"):
        self.x = x
        self.y = y
        self.cannon_type = cannon_type
        self.shoot_timer = 0
        self.angle = 0 if cannon_type == "normal" else random.uniform(0, 2 * math.pi)
        self.turn_speed = 0.02 if cannon_type == "homing" else 0
    
    def update(self, player, projectiles):
        self.shoot_timer += 1
        
        if self.cannon_type == "homing":
            # Slowly turn towards player
            target_angle = math.atan2(player.y - self.y, player.x - self.x)
            angle_diff = target_angle - self.angle
            # Normalize angle difference
            while angle_diff > math.pi:
                angle_diff -= 2 * math.pi
            while angle_diff < -math.pi:
                angle_diff += 2 * math.pi
            
            self.angle += angle_diff * self.turn_speed
        
        # Shoot projectiles
        shoot_interval = 90 if self.cannon_type == "homing" else 60
        if self.shoot_timer >= shoot_interval:
            self.shoot_timer = 0
            speed = 5 if self.cannon_type == "homing" else 7  # Increased speeds
            
            if self.cannon_type == "normal":
                # Shoot towards player
                dx = player.x - self.x
                dy = player.y - self.y
                dist = math.sqrt(dx*dx + dy*dy)
                if dist > 0:
                    vel_x = (dx / dist) * speed
                    vel_y = (dy / dist) * speed
                    projectiles.append(Projectile(self.x, self.y, vel_x, vel_y, ORANGE))
            else:  # homing
                vel_x = math.cos(self.angle) * speed
                vel_y = math.sin(self.angle) * speed
                projectiles.append(Projectile(self.x, self.y, vel_x, vel_y, BLUE))
    
    def draw(self, screen):
        color = ORANGE if self.cannon_type == "normal" else BLUE
        pygame.draw.rect(screen, color, (self.x - 8, self.y - 8, 16, 16))
        
        # Draw barrel
        barrel_length = 15
        end_x = self.x + math.cos(self.angle) * barrel_length
        end_y = self.y + math.sin(self.angle) * barrel_length
        pygame.draw.line(screen, color, (self.x, self.y), (end_x, end_y), 3)

class LevelGenerator:
    def __init__(self):
        self.platforms = []
        self.starting_platform = []
        self.lava_blocks = []
        self.cannons = []
        self.world_y = 0
        self.last_platform_y = SCREEN_HEIGHT - 100
        self.generate_initial_level()
    
    def generate_initial_level(self):
        # Generate starting platform (always the same size and position)
        start_platform_width = 200
        start_platform_x = (SCREEN_WIDTH - start_platform_width) // 2
        start_platform_y = SCREEN_HEIGHT - 50
        
        for i in range(0, start_platform_width, 20):
            self.starting_platform.append(pygame.Rect(start_platform_x + i, start_platform_y, 20, 20))
        
        # Set last platform y to be above the starting platform
        self.last_platform_y = start_platform_y - 150
        
        # Generate initial platforms above starting platform
        for i in range(10):
            self.generate_platform_section()
    
    def generate_platform_section(self):
        y = self.last_platform_y - random.randint(80, 150)
        
        # Generate platform pattern
        pattern = random.choice(['straight', 'gap', 'zigzag', 'tower'])
        
        if pattern == 'straight':
            width = random.randint(200, 400)
            x = random.randint(0, SCREEN_WIDTH - width)
            for i in range(0, width, 20):
                self.platforms.append(pygame.Rect(x + i, y, 20, 20))
        
        elif pattern == 'gap':
            # Platform with gap in middle
            left_width = random.randint(80, 150)
            gap_width = random.randint(60, 120)
            right_width = random.randint(80, 150)
            
            x = random.randint(0, SCREEN_WIDTH - left_width - gap_width - right_width)
            
            # Left platform
            for i in range(0, left_width, 20):
                self.platforms.append(pygame.Rect(x + i, y, 20, 20))
            
            # Right platform
            for i in range(0, right_width, 20):
                self.platforms.append(pygame.Rect(x + left_width + gap_width + i, y, 20, 20))
        
        elif pattern == 'zigzag':
            # Zigzag pattern
            x = random.randint(100, SCREEN_WIDTH - 300)
            for i in range(3):
                offset = (i % 2) * 100
                for j in range(0, 80, 20):
                    self.platforms.append(pygame.Rect(x + offset + j, y - i * 40, 20, 20))
        
        elif pattern == 'tower':
            # Vertical tower
            x = random.randint(100, SCREEN_WIDTH - 100)
            height = random.randint(4, 8)
            for i in range(height):
                self.platforms.append(pygame.Rect(x, y + i * 20, 20, 20))
                self.platforms.append(pygame.Rect(x + 60, y + i * 20, 20, 20))
        
        # Add obstacles
        self.add_obstacles(y)
        
        self.last_platform_y = y
    
    def add_obstacles(self, y):
        # Add lava blocks
        if random.random() < 0.3:
            lava_x = random.randint(0, SCREEN_WIDTH - 40)
            for i in range(random.randint(1, 3)):
                self.lava_blocks.append(pygame.Rect(lava_x + i * 20, y + 20, 20, 20))
        
        # Add cannons
        if random.random() < 0.4:
            cannon_x = random.randint(20, SCREEN_WIDTH - 20)
            cannon_type = random.choice(["normal", "homing"])
            self.cannons.append(Cannon(cannon_x, y - 40, cannon_type))
    
    def update(self, camera_y):
        # Generate new sections as camera moves up
        while self.last_platform_y > camera_y - SCREEN_HEIGHT:
            self.generate_platform_section()
        
        # Remove old platforms and obstacles
        cutoff_y = camera_y + SCREEN_HEIGHT + 200
        self.platforms = [p for p in self.platforms if p.y < cutoff_y]
        self.lava_blocks = [l for l in self.lava_blocks if l.y < cutoff_y]
        self.cannons = [c for c in self.cannons if c.y < cutoff_y]
    
    def draw(self, screen, camera_y):
        # Draw starting platform (lighter grey)
        for platform in self.starting_platform:
            if platform.y > camera_y - 50 and platform.y < camera_y + SCREEN_HEIGHT + 50:
                pygame.draw.rect(screen, LIGHTER_GREY, (platform.x, platform.y - camera_y, platform.width, platform.height))
        
        # Draw regular platforms
        for platform in self.platforms:
            if platform.y > camera_y - 50 and platform.y < camera_y + SCREEN_HEIGHT + 50:
                pygame.draw.rect(screen, GREY, (platform.x, platform.y - camera_y, platform.width, platform.height))
        
        # Draw lava blocks
        for lava in self.lava_blocks:
            if lava.y > camera_y - 50 and lava.y < camera_y + SCREEN_HEIGHT + 50:
                pygame.draw.rect(screen, RED, (lava.x, lava.y - camera_y, lava.width, lava.height))
        
        # Draw cannons
        for cannon in self.cannons:
            if cannon.y > camera_y - 50 and cannon.y < camera_y + SCREEN_HEIGHT + 50:
                cannon_screen = Cannon(cannon.x, cannon.y - camera_y, cannon.cannon_type)
                cannon_screen.angle = cannon.angle
                cannon_screen.draw(screen)

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Pixel Tower")
        self.clock = pygame.time.Clock()
        
        self.player = Player(SCREEN_WIDTH // 2 - PLAYER_SIZE // 2, SCREEN_HEIGHT - 100)
        self.camera_y = 0
        self.stars = [Star() for _ in range(50)]
        self.level_generator = LevelGenerator()
        self.projectiles = []
        self.game_over = False
        self.height_score = 0
        
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r and self.game_over:
                    self.restart_game()
        return True
    
    def restart_game(self):
        self.player = Player(SCREEN_WIDTH // 2 - PLAYER_SIZE // 2, SCREEN_HEIGHT - 100)
        self.camera_y = 0
        self.level_generator = LevelGenerator()
        self.projectiles = []
        self.game_over = False
        self.height_score = 0
    
    def update(self):
        if self.game_over:
            return
        
        # Update player (pass all platforms including starting platform)
        all_platforms = self.level_generator.platforms + self.level_generator.starting_platform
        self.player.update(all_platforms)
        
        # Update camera to follow player
        target_camera_y = self.player.y - SCREEN_HEIGHT * 0.7
        if target_camera_y < self.camera_y:
            self.camera_y = target_camera_y
        
        # Update height score
        self.height_score = max(self.height_score, int(-self.camera_y / 10))
        
        # Update stars
        for star in self.stars:
            star.update()
        
        # Update level generator
        self.level_generator.update(self.camera_y)
        
        # Update cannons and projectiles
        for cannon in self.level_generator.cannons:
            cannon.update(self.player, self.projectiles)
        
        for projectile in self.projectiles[:]:
            projectile.update()
            if projectile.is_off_screen():
                self.projectiles.remove(projectile)
        
        # Check collisions
        self.check_collisions()
        
        # Check if player fell off screen
        if self.player.y > self.camera_y + SCREEN_HEIGHT + 100:
            self.game_over = True
    
    def check_collisions(self):
        player_rect = pygame.Rect(self.player.x, self.player.y, PLAYER_SIZE, PLAYER_SIZE)
        
        # Check lava collision
        for lava in self.level_generator.lava_blocks:
            if player_rect.colliderect(lava):
                self.game_over = True
                return
        
        # Check projectile collision
        for projectile in self.projectiles[:]:
            proj_rect = pygame.Rect(projectile.x - projectile.size, projectile.y - projectile.size, 
                                  projectile.size * 2, projectile.size * 2)
            if player_rect.colliderect(proj_rect):
                self.game_over = True
                return
    
    def draw(self):
        self.screen.fill(BLACK)
        
        # Draw stars
        for star in self.stars:
            star.draw(self.screen)
        
        # Draw level
        self.level_generator.draw(self.screen, self.camera_y)
        
        # Draw projectiles
        for projectile in self.projectiles:
            if projectile.y > self.camera_y - 50 and projectile.y < self.camera_y + SCREEN_HEIGHT + 50:
                proj_screen = Projectile(projectile.x, projectile.y - self.camera_y, 0, 0, projectile.color)
                proj_screen.draw(self.screen)
        
        # Draw player
        player_screen_y = self.player.y - self.camera_y
        pygame.draw.rect(self.screen, WHITE, (self.player.x, player_screen_y, PLAYER_SIZE, PLAYER_SIZE))
        
        # Draw UI
        font = pygame.font.Font(None, 36)
        height_text = font.render(f"Height: {self.height_score}m", True, WHITE)
        self.screen.blit(height_text, (10, 10))
        
        if self.game_over:
            game_over_text = font.render("GAME OVER", True, WHITE)
            restart_text = font.render("Press R to restart", True, WHITE)
            text_rect = game_over_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2))
            restart_rect = restart_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 + 40))
            self.screen.blit(game_over_text, text_rect)
            self.screen.blit(restart_text, restart_rect)
        
        pygame.display.flip()
    
    def run(self):
        running = True
        while running:
            running = self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

if __name__ == "__main__":
    game = Game()
    game.run()
